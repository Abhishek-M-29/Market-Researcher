"""
Agent 8: PDF Compiler

Role: Generate the final "Team Bible" report.
Uses: LLM for narrative + ReportLab for PDF generation

The PDF Compiler:
1. Takes all research data from state
2. Synthesizes into a professional report
3. Generates a PDF file
"""

import json
import os
from datetime import datetime
from typing import Dict, Any
from langchain_core.messages import HumanMessage, SystemMessage

from src.graph.state import MarketState
from src.config.prompts import PDF_COMPILER_PROMPT
from src.utils.llm import get_analysis_llm


def generate_markdown_report(state: MarketState) -> str:
    """
    Generate a Markdown report from the state.
    
    This can be converted to PDF using tools like pandoc or directly displayed.
    """
    idea = state.get("raw_idea", "")
    region = state.get("target_region", "India")
    verified_pains = state.get("verified_pains", [])
    competitors = state.get("competitor_table", [])
    personas = state.get("personas", [])
    features = state.get("feature_list", [])
    revenue_model = state.get("revenue_model", {})
    business_model = state.get("business_model", {})
    positioning = state.get("recommended_positioning", "")
    
    # Generate timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
    
    # Build the report
    report = f"""# Market Research Report: {idea}

**Generated:** {timestamp}  
**Target Region:** {region}

---

## Executive Summary

{positioning}

---

## 1. Verified Pain Points

The following pain points have been verified with statistical evidence:

| Pain Point | Statistic | Source | Year |
|------------|-----------|--------|------|
"""
    
    for pain in verified_pains[:10]:
        report += f"| {pain.get('pain', 'N/A')[:50]} | {pain.get('stat', 'N/A')} | {pain.get('source', 'N/A')} | {pain.get('year', 'N/A')} |\n"
    
    report += """
---

## 2. Competitive Landscape

### Competitor Matrix

| Competitor | Best At | Lag | Lack | Gap (Our Opportunity) |
|------------|---------|-----|------|----------------------|
"""
    
    for comp in competitors[:5]:
        report += f"| {comp.get('name', 'N/A')} | {comp.get('best_at', 'N/A')[:30]} | {comp.get('lag', 'N/A')[:30]} | {comp.get('lack', 'N/A')[:30]} | {comp.get('gap', 'N/A')[:30]} |\n"
    
    report += """
---

## 3. Target Personas

"""
    
    for i, persona in enumerate(personas[:5], 1):
        report += f"""### Persona {i}: {persona.get('name', 'Unknown')}

- **Segment:** {persona.get('segment', 'N/A')}
- **Age Range:** {persona.get('age_range', 'N/A')}
- **Income:** {persona.get('income_bracket', 'N/A')}
- **Tech Comfort:** {persona.get('tech_comfort', 'N/A')}
- **Trust Deficit Score:** {persona.get('trust_deficit_score', 'N/A')}/10
- **Language Preference:** {persona.get('language_preference', 'N/A')}

{persona.get('description', 'No description available.')}

"""
    
    report += """---

## 4. Proposed Features (by RICE Score)

| Rank | Feature | RICE Score | Effort (weeks) | Target Persona |
|------|---------|------------|----------------|----------------|
"""
    
    for i, feature in enumerate(features[:15], 1):
        report += f"| {i} | {feature.get('name', 'N/A')[:40]} | {feature.get('rice_score', 0):,.0f} | {feature.get('effort', 'N/A')} | {feature.get('persona_target', 'N/A')[:20]} |\n"
    
    report += f"""
---

## 5. Financial Projections

### Unit Economics

| Metric | Value |
|--------|-------|
| Customer Acquisition Cost (CAC) | ₹{revenue_model.get('cac', 0):,.0f} |
| Average Revenue Per User (ARPU) | ₹{revenue_model.get('arpu', 0):,.0f}/month |
| Gross Margin | {revenue_model.get('gross_margin', 0)*100:.0f}% |
| Monthly Churn Rate | {revenue_model.get('churn_rate', 0)*100:.1f}% |
| Lifetime Value (LTV) | ₹{revenue_model.get('ltv', 0):,.0f} |
| **LTV/CAC Ratio** | **{revenue_model.get('ltv_cac_ratio', 0):.2f}** |
| Payback Period | {revenue_model.get('payback_months', 0):.1f} months |

### Pricing Tiers

"""
    
    pricing = revenue_model.get('pricing_tiers', {})
    for tier, price in pricing.items():
        report += f"- **{tier}:** ₹{price:,.0f}/month\n"
    
    report += f"""
### Business Model

**Key Partners:**
"""
    
    partners = business_model.get('key_partners', [])
    for partner in partners:
        report += f"- {partner}\n"
    
    report += f"""
**Revenue Streams:**
"""
    
    streams = business_model.get('revenue_streams', [])
    for stream in streams:
        report += f"- {stream}\n"
    
    report += """
---

## 6. Appendix

### Data Sources

All claims in this report are backed by verified sources. See the individual pain points for specific citations.

---

*This report was generated by the Multi-Agent Market Research Engine.*
"""
    
    return report


def run_pdf_compiler(state: MarketState) -> Dict[str, Any]:
    """
    Execute the PDF Compiler agent.
    
    Inputs from state:
        - All research data
    
    Outputs to state:
        - final_report_path: Path to the generated report
        - report_markdown: The report content
    """
    # Generate the Markdown report
    markdown_report = generate_markdown_report(state)
    
    # Save to file
    idea = state.get("raw_idea", "research")
    # Clean idea for filename
    safe_idea = "".join(c if c.isalnum() or c in (' ', '-', '_') else '' for c in idea)[:30]
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    filename = f"report_{safe_idea}_{timestamp}.md"
    filepath = os.path.join(os.getcwd(), "reports", filename)
    
    # Ensure reports directory exists
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    
    # Write the report
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(markdown_report)
    
    return {
        "final_report_path": filepath,
        "report_markdown": markdown_report
    }
